{"version":3,"sources":["../src/obaa.js","../src/path.js","../src/vue.js"],"names":["obaa","target","arr","callback","eventPropArr","isArray","length","__o_","__r_","__p_","mock","prop","hasOwnProperty","isInArray","push","watch","isString","__c_","all","propChanged","root","methods","forEach","item","old","Array","prototype","slice","call","this","result","apply","arguments","RegExp","test","triggerStr","cprop","isFunction","onPropertyChanged","substring","toUpperCase","path","currentValue","value","oldValue","nan","rootName","getRootName","i","len","handler","indexOf","obj","Object","toString","isNaN","split","OBJECTTYPE","ARRAYTYPE","tempPath","keys","getUpdatePath","data","key","type","dataToPath","_arrayToPath","_objToPath","index","needUpdate","diffResult","updatePath","keyA","includePath","keyB","pathA","pathB","next","fixPath","mpPath","replace","Number","components","destroyed","options","beforeCreate","useSelf","getPath","updateSelfComponents","__$updateSelfPath_","splice","$store","computed","recUpdate","$forceUpdate","add","set","size","Vue","use","Vuex","$","render","comp","renderTo","store","h","$mount","patch","component","Omiv"],"mappings":"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","file":"omiv.min.js","sourcesContent":["export function obaa(target, arr, callback) {\n  let eventPropArr = []\n  if (isArray(target)) {\n    if (target.length === 0) {\n      target.__o_ = {\n        __r_: target,\n        __p_: '#'\n      }\n    }\n    mock(target, target)\n  }\n  for (let prop in target) {\n    if (target.hasOwnProperty(prop)) {\n      if (callback) {\n        if (isArray(arr) && isInArray(arr, prop)) {\n          eventPropArr.push(prop)\n          watch(target, prop, null, target)\n        } else if (isString(arr) && prop === arr) {\n          eventPropArr.push(prop)\n          watch(target, prop, null, target)\n        }\n      } else {\n        eventPropArr.push(prop)\n        watch(target, prop, null, target)\n      }\n    }\n  }\n  if (!target.__c_) {\n    target.__c_ = []\n  }\n  let propChanged = callback ? callback : arr\n  target.__c_.push({\n    all: !callback,\n    propChanged,\n    eventPropArr\n  })\n}\n\nlet triggerStr = [\n  'concat',\n  'copyWithin',\n  'fill',\n  'pop',\n  'push',\n  'reverse',\n  'shift',\n  'sort',\n  'splice',\n  'unshift',\n  'size'\n].join(',')\n\nlet methods = [\n  'concat',\n  'copyWithin',\n  'entries',\n  'every',\n  'fill',\n  'filter',\n  'find',\n  'findIndex',\n  'forEach',\n  'includes',\n  'indexOf',\n  'join',\n  'keys',\n  'lastIndexOf',\n  'map',\n  'pop',\n  'push',\n  'reduce',\n  'reduceRight',\n  'reverse',\n  'shift',\n  'slice',\n  'some',\n  'sort',\n  'splice',\n  'toLocaleString',\n  'toString',\n  'unshift',\n  'values',\n  'size'\n]\n\nfunction mock(target, root) {\n  methods.forEach(item => {\n    target[item] = function() {\n      let old = Array.prototype.slice.call(this, 0)\n      let result = Array.prototype[item].apply(\n        this,\n        Array.prototype.slice.call(arguments)\n      )\n      if (new RegExp('\\\\b' + item + '\\\\b').test(triggerStr)) {\n        for (let cprop in this) {\n          if (this.hasOwnProperty(cprop) && !isFunction(this[cprop])) {\n            watch(this, cprop, this.__o_.__p_, root)\n          }\n        }\n        //todo\n        onPropertyChanged(\n          'Array-' + item,\n          this,\n          old,\n          this,\n          this.__o_.__p_,\n          root\n        )\n      }\n      return result\n    }\n    target[\n      'pure' + item.substring(0, 1).toUpperCase() + item.substring(1)\n    ] = function() {\n      return Array.prototype[item].apply(\n        this,\n        Array.prototype.slice.call(arguments)\n      )\n    }\n  })\n}\n\nfunction watch(target, prop, path, root) {\n  if (prop === '__o_') return\n  if (isFunction(target[prop])) return\n  if (!target.__o_)\n    target.__o_ = {\n      __r_: root\n    }\n  if (path !== undefined && path !== null) {\n    target.__o_.__p_ = path\n  } else {\n    target.__o_.__p_ = '#'\n  }\n\n  let currentValue = (target.__o_[prop] = target[prop])\n  Object.defineProperty(target, prop, {\n    get() {\n      return this.__o_[prop]\n    },\n    set(value) {\n      let old = this.__o_[prop]\n      this.__o_[prop] = value\n      onPropertyChanged(prop, value, old, this, target.__o_.__p_, root)\n    },\n    configurable: true,\n    enumerable: true\n  })\n  if (typeof currentValue === 'object') {\n    if (isArray(currentValue)) {\n      mock(currentValue, root)\n      if (currentValue.length === 0) {\n        if (!currentValue.__o_) currentValue.__o_ = {}\n        if (path !== undefined && path !== null) {\n          currentValue.__o_.__p_ = path + '-' + prop\n        } else {\n          currentValue.__o_.__p_ = '#-' + prop\n        }\n      }\n    }\n    for (let cprop in currentValue) {\n      if (currentValue.hasOwnProperty(cprop)) {\n        watch(currentValue, cprop, target.__o_.__p_ + '-' + prop, root)\n      }\n    }\n  }\n}\n\nfunction onPropertyChanged(prop, value, oldValue, target, path, root) {\n  if (value !== oldValue && !(nan(value) && nan(oldValue)) && root.__c_) {\n    let rootName = getRootName(prop, path)\n    for (let i = 0, len = root.__c_.length; i < len; i++) {\n      let handler = root.__c_[i]\n      if (\n        handler.all ||\n        isInArray(handler.eventPropArr, rootName) ||\n        rootName.indexOf('Array-') === 0\n      ) {\n        handler.propChanged.call(target, prop, value, oldValue, path)\n      }\n    }\n  }\n\n  if (prop.indexOf('Array-') !== 0 && typeof value === 'object') {\n    watch(target, prop, target.__o_.__p_, root)\n  }\n}\n\nfunction isFunction(obj) {\n  return Object.prototype.toString.call(obj) === '[object Function]'\n}\n\nfunction nan(value) {\n  return typeof value === 'number' && isNaN(value)\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]'\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string'\n}\n\nfunction isInArray(arr, item) {\n  for (let i = arr.length; --i > -1; ) {\n    if (item === arr[i]) return true\n  }\n  return false\n}\n\nfunction getRootName(prop, path) {\n  if (path === '#') {\n    return prop\n  }\n  return path.split('-')[1]\n}\n\nobaa.add = function(obj, prop) {\n  watch(obj, prop, obj.__o_.__p_, obj.__o_.__r_)\n}\n\nobaa.set = function(obj, prop, value) {\n  watch(obj, prop, obj.__o_.__p_, obj.__o_.__r_)\n  obj[prop] = value\n}\n\n//@ts-ignore\n/* eslint-disable */\nArray.prototype.size = function (length) {\n  this.length = length\n}","const OBJECTTYPE = '[object Object]'\nconst ARRAYTYPE = '[object Array]'\n\nexport function getUsing(data, paths) {\n  const obj = []\n  paths.forEach((path, index) => {\n    const isPath = typeof path === 'string'\n    if (isPath) {\n      obj[index] = getTargetByPath(data, path)\n    } else {\n      const key = Object.keys(path)[0]\n      const value = path[key]\n      if (typeof value === 'string') {\n        obj[index] = getTargetByPath(data, value)\n      } else {\n        const tempPath = value[0]\n        if (typeof tempPath === 'string') {\n          const tempVal = getTargetByPath(data, tempPath)\n          obj[index] = value[1] ? value[1](tempVal) : tempVal\n        } else {\n          const args = []\n          tempPath.forEach(path => {\n            args.push(getTargetByPath(data, path))\n          })\n          obj[index] = value[1].apply(null, args)\n        }\n      }\n      obj[key] = obj[index]\n    }\n  })\n  return obj\n}\n\nexport function getTargetByPath(origin, path) {\n  const arr = path\n    .replace(/]/g, '')\n    .replace(/\\[/g, '.')\n    .split('.')\n  let current = origin\n  for (let i = 0, len = arr.length; i < len; i++) {\n    current = current[arr[i]]\n  }\n  return current\n}\n\nexport function getPath(obj) {\n  if (Object.prototype.toString.call(obj) === '[object Array]') {\n    const result = {}\n    obj.forEach(item => {\n      if (typeof item === 'string') {\n        result[item] = true\n      } else {\n        const tempPath = item[Object.keys(item)[0]]\n        if (typeof tempPath === 'string') {\n          result[tempPath] = true\n        } else if (typeof tempPath[0] === 'string') {\n          result[tempPath[0]] = true\n        } else {\n          tempPath[0].forEach(path => (result[path] = true))\n        }\n      }\n    })\n    return result\n  }\n  return getUpdatePath(obj)\n}\n\nexport function getUpdatePath(data) {\n  const result = {}\n  dataToPath(data, result)\n  return result\n}\n\nfunction dataToPath(data, result) {\n  Object.keys(data).forEach(key => {\n    result[key] = true\n    const type = Object.prototype.toString.call(data[key])\n    if (type === OBJECTTYPE) {\n      _objToPath(data[key], key, result)\n    } else if (type === ARRAYTYPE) {\n      _arrayToPath(data[key], key, result)\n    }\n  })\n}\n\nfunction _objToPath(data, path, result) {\n  Object.keys(data).forEach(key => {\n    result[path + '.' + key] = true\n    delete result[path]\n    const type = Object.prototype.toString.call(data[key])\n    if (type === OBJECTTYPE) {\n      _objToPath(data[key], path + '.' + key, result)\n    } else if (type === ARRAYTYPE) {\n      _arrayToPath(data[key], path + '.' + key, result)\n    }\n  })\n}\n\nfunction _arrayToPath(data, path, result) {\n  data.forEach((item, index) => {\n    result[path + '[' + index + ']'] = true\n    delete result[path]\n    const type = Object.prototype.toString.call(item)\n    if (type === OBJECTTYPE) {\n      _objToPath(item, path + '[' + index + ']', result)\n    } else if (type === ARRAYTYPE) {\n      _arrayToPath(item, path + '[' + index + ']', result)\n    }\n  })\n}\n\nexport function needUpdate(diffResult, updatePath) {\n  for (let keyA in diffResult) {\n    if (updatePath[keyA]) {\n      return true\n    }\n    for (let keyB in updatePath) {\n      if (includePath(keyA, keyB)) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction includePath(pathA, pathB) {\n  if (pathA.indexOf(pathB) === 0) {\n    const next = pathA.substr(pathB.length, 1)\n    if (next === '[' || next === '.') {\n      return true\n    }\n  }\n  return false\n}\n\nexport function fixPath(path) {\n  let mpPath = ''\n  const arr = path.replace('#-', '').split('-')\n  arr.forEach((item, index) => {\n    if (index) {\n      if (isNaN(Number(item))) {\n        mpPath += '.' + item\n      } else {\n        mpPath += '[' + item + ']'\n      }\n    } else {\n      mpPath += item\n    }\n  })\n  return mpPath\n}\n","import Vue from 'vue'\nimport Vuex from 'vuex'\n\nimport { obaa } from './obaa'\nimport { getPath, needUpdate, fixPath } from './path'\n\n\nVue.use(Vuex)\n\nconst components = []\nconst updateSelfComponents = []\n\nexport function $(options) {\n\n  const beforeCreate = options.beforeCreate\n  const destroyed = options.destroyed\n  const use = options.use\n  const useSelf = options.useSelf\n  options.computed = options.computed || {}\n\n  options.beforeCreate = function () {\n    if (use) {\n      this.__$updatePath_ = getPath(use)\n      components.push(this)\n    }\n    if (useSelf) {\n      this.__$updateSelfPath_ = getPath(useSelf)\n      updateSelfComponents.push(this)\n    }\n    beforeCreate && beforeCreate.apply(this, arguments)\n  }\n\n  options.destroyed = function () {\n    for (let i = 0, len = components.length; i < len; i++) {\n      if (components[i] === this) {\n        components.splice(i, 1)\n        break\n      }\n    }\n\n    destroyed && destroyed.apply(this, arguments)\n  }\n\n  options.computed.state = function () {\n    return this.$store.data\n  }\n\n  options.computed.store = function () {\n    return this.$store\n  }\n\n  return options\n\n}\n\n$.render = function (comp, renderTo, store) {\n\n  Vue.config.productionTip = false\n\n  new Vue({\n    render: h => h(comp),\n    store\n  }).$mount(renderTo)\n\n  obaa(store.data, (prop, val, old, path) => {\n    const patch = {}\n\n    patch[fixPath(path + '-' + prop)] = true\n    components.forEach(component => {\n      if (\n        component.__$updatePath_ &&\n        needUpdate(patch, component.__$updatePath_)\n      ) {\n        recUpdate(component)\n\n      }\n    })\n\n    updateSelfComponents.forEach(component => {\n      if (\n        component.__$updateSelfPath_ &&\n        needUpdate(patch, component.__$updateSelfPath_)\n      ) {\n        component.$forceUpdate()\n\n      }\n    })\n  })\n}\n\nfunction recUpdate(root) {\n  root.$forceUpdate()\n  root.$children.forEach(child => {\n    recUpdate(child)\n  })\n}"]}