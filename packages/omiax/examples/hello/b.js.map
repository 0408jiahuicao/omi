{"version":3,"file":"b.js","sources":["../../src/layout/layout.js","../../src/layout/layout-node.js","../../src/render.js","../../src/h.js","../../src/index.js","main.js"],"sourcesContent":["// https://github.com/facebook/css-layout\n\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  function capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function getSpacing(node, type, suffix, location) {\n    var key = type + capitalizeFirst(location) + suffix;\n    if (key in node.style) {\n      return node.style[key];\n    }\n\n    key = type + suffix;\n    if (key in node.style) {\n      return node.style[key];\n    }\n\n    return 0;\n  }\n\n  function getPositiveSpacing(node, type, suffix, location) {\n    var key = type + capitalizeFirst(location) + suffix;\n    if (key in node.style && node.style[key] >= 0) {\n      return node.style[key];\n    }\n\n    key = type + suffix;\n    if (key in node.style && node.style[key] >= 0) {\n      return node.style[key];\n    }\n\n    return 0;\n  }\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  function getMargin(node, location) {\n    return getSpacing(node, 'margin', '', location);\n  }\n\n  function getPadding(node, location) {\n    return getPositiveSpacing(node, 'padding', '', location);\n  }\n\n  function getBorder(node, location) {\n    return getPositiveSpacing(node, 'border', 'Width', location);\n  }\n\n  function getPaddingAndBorder(node, location) {\n    return getPadding(node, location) + getBorder(node, location);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getMargin(node, leading[axis]) + getMargin(node, trailing[axis]);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getPaddingAndBorder(node, leading[axis]) + getPaddingAndBorder(node, trailing[axis]);\n  }\n\n  function getJustifyContent(node) {\n    if ('justifyContent' in node.style) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if ('alignSelf' in child.style) {\n      return child.style.alignSelf;\n    }\n    if ('alignItems' in node.style) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function getFlexDirection(node) {\n    if ('flexDirection' in node.style) {\n      return node.style.flexDirection;\n    }\n    return 'column';\n  }\n\n  function getPositionType(node) {\n    if ('position' in node.style) {\n      return node.style.position;\n    }\n    return 'relative';\n  }\n\n  function getFlex(node) {\n    return node.style.flex;\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      getFlex(node) > 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isDimDefined(node, axis) {\n    return !isUndefined(node.style[dim[axis]]) && node.style[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return !isUndefined(node.style[pos]);\n  }\n\n  function isMeasureDefined(node) {\n    return 'measure' in node.style;\n  }\n\n  function getPosition(node, pos) {\n    if (pos in node.style) {\n      return node.style[pos];\n    }\n    return 0;\n  }\n\n  // When the user specifically sets a value for width or height\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (!isUndefined(node.layout[dim[axis]])) {\n      return;\n    }\n    // We only run if there's a width or height defined\n    if (!isDimDefined(node, axis)) {\n      return;\n    }\n\n    // The dimensions can never be smaller than the padding and border\n    node.layout[dim[axis]] = fmaxf(\n      node.style[dim[axis]],\n      getPaddingAndBorderAxis(node, axis)\n    );\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (leading[axis] in node.style) {\n      return getPosition(node, leading[axis]);\n    }\n    return -getPosition(node, trailing[axis]);\n  }\n\n  var leading = {\n    row: 'left',\n    column: 'top'\n  };\n  var trailing = {\n    row: 'right',\n    column: 'bottom'\n  };\n  var pos = {\n    row: 'left',\n    column: 'top'\n  };\n  var dim = {\n    row: 'width',\n    column: 'height'\n  };\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  var CSS_UNDEFINED = undefined;\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  return function layoutNode(node, parentMaxWidth) {\n    var/*css_flex_direction_t*/ mainAxis = getFlexDirection(node);\n    var/*css_flex_direction_t*/ crossAxis = mainAxis === CSS_FLEX_DIRECTION_ROW ?\n      CSS_FLEX_DIRECTION_COLUMN :\n      CSS_FLEX_DIRECTION_ROW;\n\n    // Handle width and height style attributes\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis);\n\n    // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n    node.layout[leading[mainAxis]] += getMargin(node, leading[mainAxis]) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getMargin(node, leading[crossAxis]) +\n      getRelativePosition(node, crossAxis);\n\n    if (isMeasureDefined(node)) {\n      var/*float*/ width = CSS_UNDEFINED;\n      if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n        width = node.style.width;\n      } else if (!isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_ROW]])) {\n        width = node.layout[dim[CSS_FLEX_DIRECTION_ROW]];\n      } else {\n        width = parentMaxWidth -\n          getMarginAxis(node, CSS_FLEX_DIRECTION_ROW);\n      }\n      width -= getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n\n      // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n      var/*bool*/ isRowUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_ROW) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_ROW]]);\n      var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n      // Let's not measure the text if we already know both dimensions\n      if (isRowUndefined || isColumnUndefined) {\n        var/*css_dim_t*/ measure_dim = node.style.measure(\n          /*(c)!node->context,*/\n          width\n        );\n        if (isRowUndefined) {\n          node.layout.width = measure_dim.width +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n        }\n        if (isColumnUndefined) {\n          node.layout.height = measure_dim.height +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n        }\n      }\n      return;\n    }\n\n    // Pre-fill some dimensions straight from the parent\n    for (var/*int*/ i = 0; i < node.children.length; ++i) {\n      var/*css_node_t**/ child = node.children[i];\n      // Pre-fill cross axis dimensions when the child is using stretch before\n      // we call the recursive layout pass\n      if (getAlignItem(node, child) === CSS_ALIGN_STRETCH &&\n          getPositionType(child) === CSS_POSITION_RELATIVE &&\n          !isUndefined(node.layout[dim[crossAxis]]) &&\n          !isDimDefined(child, crossAxis)) {\n        child.layout[dim[crossAxis]] = fmaxf(\n          node.layout[dim[crossAxis]] -\n            getPaddingAndBorderAxis(node, crossAxis) -\n            getMarginAxis(child, crossAxis),\n          // You never want to go smaller than padding\n          getPaddingAndBorderAxis(child, crossAxis)\n        );\n      } else if (getPositionType(child) == CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (var/*int*/ ii = 0; ii < 2; ii++) {\n          var/*css_flex_direction_t*/ axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(child, axis) &&\n              isPosDefined(child, leading[axis]) &&\n              isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(\n              node.layout[dim[axis]] -\n              getPaddingAndBorderAxis(node, axis) -\n              getMarginAxis(child, axis) -\n              getPosition(child, leading[axis]) -\n              getPosition(child, trailing[axis]),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, axis)\n            );\n          }\n        }\n      }\n    }\n\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\n    if (!isUndefined(node.layout[dim[mainAxis]])) {\n      definedMainDim = node.layout[dim[mainAxis]] -\n          getPaddingAndBorderAxis(node, mainAxis);\n    }\n\n    // We want to execute the next two loops one per line with flex-wrap\n    var/*int*/ startLine = 0;\n    var/*int*/ endLine = 0;\n    var/*int*/ nextOffset = 0;\n    var/*int*/ alreadyComputedNextLayout = 0;\n    // We aggregate the total dimensions of the container in those two variables\n    var/*float*/ linesCrossDim = 0;\n    var/*float*/ linesMainDim = 0;\n    while (endLine < node.children.length) {\n      // <Loop A> Layout non flexible children and count children by type\n\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var/*float*/ mainContentDim = 0;\n\n      // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n      var/*int*/ flexibleChildrenCount = 0;\n      var/*float*/ totalFlexible = 0;\n      var/*int*/ nonFlexibleChildrenCount = 0;\n      for (var/*int*/ i = startLine; i < node.children.length; ++i) {\n        var/*css_node_t**/ child = node.children[i];\n        var/*float*/ nextContentDim = 0;\n\n        // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n        if (!isUndefined(node.layout[dim[mainAxis]]) && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += getFlex(child);\n\n          // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information to compute the\n          // remaining space.\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n            getMarginAxis(child, mainAxis);\n\n        } else {\n          var/*float*/ maxWidth = CSS_UNDEFINED;\n          if (mainAxis === CSS_FLEX_DIRECTION_ROW) {\n            // do nothing\n          } else if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n            maxWidth = node.layout[dim[CSS_FLEX_DIRECTION_ROW]] -\n              getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n          } else {\n            maxWidth = parentMaxWidth -\n              getMarginAxis(node, CSS_FLEX_DIRECTION_ROW) -\n              getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n          }\n\n          // This is the main recursive call. We layout non flexible children.\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(child, maxWidth);\n          }\n\n          // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++;\n            // At this point we know the final size and margin of the element.\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        }\n\n        // The element we are about to add would make us go to the next line\n        if (isFlexWrap(node) &&\n            !isUndefined(node.layout[dim[mainAxis]]) &&\n            mainContentDim + nextContentDim > definedMainDim &&\n            // If there's only one element, then it's bigger than the content\n            // and needs its own line\n            i !== startLine) {\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      }\n\n      // <Loop B> Layout flexible children and allocate empty space\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // The remaining available space that needs to be allocated\n      var/*float*/ remainingMainDim = 0;\n      if (!isUndefined(node.layout[dim[mainAxis]])) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      }\n\n      // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n      if (flexibleChildrenCount !== 0) {\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n\n        // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        }\n        // We iterate over the full array and only apply the action on flexible\n        // children. This is faster than actually allocating a new array that\n        // contains only flexible children.\n        for (var/*int*/ i = startLine; i < endLine; ++i) {\n          var/*css_node_t**/ child = node.children[i];\n          if (isFlex(child)) {\n            // At this point we know the final size of the element in the main\n            // dimension\n            child.layout[dim[mainAxis]] = flexibleMainDim * getFlex(child) +\n              getPaddingAndBorderAxis(child, mainAxis);\n\n            var/*float*/ maxWidth = CSS_UNDEFINED;\n            if (mainAxis === CSS_FLEX_DIRECTION_ROW) {\n              // do nothing\n            } else if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n              maxWidth = node.layout[dim[CSS_FLEX_DIRECTION_ROW]] -\n                getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n            } else {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, CSS_FLEX_DIRECTION_ROW) -\n                getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n            }\n\n            // And we recursively call the layout algorithm for this child\n            layoutNode(child, maxWidth);\n          }\n        }\n\n      // We use justifyContent to figure out how to allocate the remaining\n      // space available\n      } else {\n        var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n        if (justifyContent === CSS_JUSTIFY_FLEX_START) {\n          // Do nothing\n        } else if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim /\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      // <Loop C> Position elements in the main axis and compute dimensions\n\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n      var/*float*/ crossDim = 0;\n      var/*float*/ mainDim = leadingMainDim +\n        getPaddingAndBorder(node, leading[mainAxis]);\n\n      for (var/*int*/ i = startLine; i < endLine; ++i) {\n        var/*css_node_t**/ child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n            getBorder(node, leading[mainAxis]) +\n            getMargin(child, leading[mainAxis]);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n        }\n\n        // Now that we placed the element, we need to update the variables\n        // We only need to do that for relative elements. Absolute elements\n        // do not take part in that phase.\n        if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n          // The main dimension is the sum of all the elements dimension plus\n          // the spacing.\n          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n          // The cross dimension is the max of the elements dimension since there\n          // can only be one element in that cross dimension.\n          crossDim = fmaxf(crossDim, getDimWithMargin(child, crossAxis));\n        }\n      }\n\n      var/*float*/ containerMainAxis = node.layout[dim[mainAxis]];\n      // If the user didn't specify a width or height, and it has not been set\n      // by the container, then we set it via the children.\n      if (isUndefined(node.layout[dim[mainAxis]])) {\n        containerMainAxis = fmaxf(\n          // We're missing the last padding at this point to get the final\n          // dimension\n          mainDim + getPaddingAndBorder(node, trailing[mainAxis]),\n          // We can never assign a width smaller than the padding and borders\n          getPaddingAndBorderAxis(node, mainAxis)\n        );\n      }\n\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n      if (isUndefined(node.layout[dim[crossAxis]])) {\n        containerCrossAxis = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          crossDim + getPaddingAndBorderAxis(node, crossAxis),\n          getPaddingAndBorderAxis(node, crossAxis)\n        );\n      }\n\n      // <Loop D> Position elements in the cross axis\n\n      for (var/*int*/ i = startLine; i < endLine; ++i) {\n        var/*css_node_t**/ child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n            getBorder(node, leading[crossAxis]) +\n            getMargin(child, leading[crossAxis]);\n\n        } else {\n          var/*float*/ leadingCrossDim = getPaddingAndBorder(node, leading[crossAxis]);\n\n          // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n            if (alignItem === CSS_ALIGN_FLEX_START) {\n              // Do nothing\n            } else if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been set\n              // previously.\n              if (!isDimDefined(child, crossAxis)) {\n                child.layout[dim[crossAxis]] = fmaxf(\n                  containerCrossAxis -\n                    getPaddingAndBorderAxis(node, crossAxis) -\n                    getMarginAxis(child, crossAxis),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, crossAxis)\n                );\n              }\n            } else {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var/*float*/ remainingCrossDim = containerCrossAxis -\n                getPaddingAndBorderAxis(node, crossAxis) -\n                getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          }\n\n          // And we apply the position\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      startLine = endLine;\n    }\n\n    // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n    if (isUndefined(node.layout[dim[mainAxis]])) {\n      node.layout[dim[mainAxis]] = fmaxf(\n        // We're missing the last padding at this point to get the final\n        // dimension\n        linesMainDim + getPaddingAndBorder(node, trailing[mainAxis]),\n        // We can never assign a width smaller than the padding and borders\n        getPaddingAndBorderAxis(node, mainAxis)\n      );\n    }\n\n    if (isUndefined(node.layout[dim[crossAxis]])) {\n      node.layout[dim[crossAxis]] = fmaxf(\n        // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        linesCrossDim + getPaddingAndBorderAxis(node, crossAxis),\n        getPaddingAndBorderAxis(node, crossAxis)\n      );\n    }\n\n    // <Loop E> Calculate dimensions for absolutely positioned elements\n\n    for (var/*int*/ i = 0; i < node.children.length; ++i) {\n      var/*css_node_t**/ child = node.children[i];\n      if (getPositionType(child) == CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (var/*int*/ ii = 0; ii < 2; ii++) {\n          var/*css_flex_direction_t*/ axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(child, axis) &&\n              isPosDefined(child, leading[axis]) &&\n              isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(\n              node.layout[dim[axis]] -\n              getPaddingAndBorderAxis(node, axis) -\n              getMarginAxis(child, axis) -\n              getPosition(child, leading[axis]) -\n              getPosition(child, trailing[axis]),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, axis)\n            );\n          }\n        }\n        for (var/*int*/ ii = 0; ii < 2; ii++) {\n          var/*css_flex_direction_t*/ axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (isPosDefined(child, trailing[axis]) &&\n              !isPosDefined(child, leading[axis])) {\n            child.layout[leading[axis]] =\n              node.layout[dim[axis]] -\n              child.layout[dim[axis]] -\n              getPosition(child, trailing[axis]);\n          }\n        }\n      }\n    }\n  };\n})();\n\nexport default computeLayout","// https://github.com/Flipboard/react-canvas\n\n/**\nCopyright (c) 2015, Flipboard\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\n* Neither the name of Flipboard nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n'use strict';\n\nimport  computeLayout  from './layout';\n\n/**\n * This computes the CSS layout for a RenderLayer tree and mutates the frame\n * objects at each node.\n *\n * @param {Renderlayer} root\n * @return {Object}\n */\nfunction layoutNode (root) {\n  var rootNode = createNode(root);\n  computeLayout(rootNode);\n  walkNode(rootNode);\n  return rootNode;\n}\n\nfunction createNode (layer) {\n  return {\n    layer: layer,\n    layout: {\n      width: undefined, // computeLayout will mutate\n      height: undefined, // computeLayout will mutate\n      top: 0,\n      left: 0,\n    },\n    style: (layer.attributes && layer.attributes.style) || {},\n    children: (layer.children || []).map(createNode)\n  };\n}\n\nfunction walkNode (node, parentLeft, parentTop) {\n  node.layer.frame.x = node.layout.left + (parentLeft || 0);\n  node.layer.frame.y = node.layout.top + (parentTop || 0);\n  node.layer.frame.width = node.layout.width;\n  node.layer.frame.height = node.layout.height;\n  if (node.children && node.children.length > 0) {\n    node.children.forEach(function (child) {\n      walkNode(child, node.layer.frame.x, node.layer.frame.y);\n    });\n  }\n}\n\nexport default layoutNode;","import layout from './layout/layout-node'\n\nexport function render(node){\n  console.log(layout(node()))\n}\n","const stack = []\n\n/**\n * JSX/hyperscript reviver.\n * @see http://jasonformat.com/wtf-is-jsx\n * Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\n * Note: this is exported as both `h()` and `createElement()` for compatibility reasons.\n *\n * Creates a VNode (virtual DOM element). A tree of VNodes can be used as a lightweight representation\n * of the structure of a DOM tree. This structure can be realized by recursively comparing it against\n * the current _actual_ DOM structure, and applying only the differences.\n *\n * `h()`/`createElement()` accepts an element name, a list of attributes/props,\n * and optionally children to append to the element.\n *\n * @example The following DOM tree\n *\n * `<div id=\"foo\" name=\"bar\">Hello!</div>`\n *\n * can be constructed using this function as:\n *\n * `h('div', { id: 'foo', name : 'bar' }, 'Hello!');`\n *\n * @param {string} nodeName\tAn element name. Ex: `div`, `a`, `span`, etc.\n * @param {Object} attributes\tAny attributes/props to set on the created element.\n * @param rest\t\t\tAdditional arguments are taken to be children to append. Can be infinitely nested Arrays.\n *\n * @public\n */\nexport function h(type, attributes) {\n  let children = [],\n    lastSimple,\n    child,\n    simple,\n    i\n  for (i = arguments.length; i-- > 2;) {\n    stack.push(arguments[i])\n  }\n  if (attributes && attributes.children != null) {\n    if (!stack.length) stack.push(attributes.children)\n    delete attributes.children\n  }\n\n  let p = {}\n  if (type !== 'text') {\n    while (stack.length) {\n      if ((child = stack.pop()) && child.pop !== undefined) {\n        for (i = child.length; i--;) stack.push(child[i])\n      } else {\n        if (typeof child === 'boolean') child = null\n\n        if ((simple = typeof type !== 'function')) {\n          if (child == null) child = ''\n          else if (typeof child === 'number') child = String(child)\n          else if (typeof child !== 'string') simple = false\n        }\n\n        if (simple && lastSimple) {\n          children[children.length - 1] += child\n        } else if (children.length === 0) {\n          children = [child]\n        } else {\n          children.push(child)\n        }\n\n        lastSimple = simple\n      }\n    }\n  } else {\n    p.value = stack.pop()\n  }\n\n\n\n  p.type = type\n  p.frame = {\n    \"x\": 0,\n    \"y\": 0,\n    \"width\": 0,\n    \"height\": 0\n  }\n  p.children = children\n  p.attributes = attributes == null ? undefined : attributes\n  p.key = attributes == null ? undefined : attributes.key\n\n\n  return p\n}\n","import { render } from './render'\nimport { h } from './h'\n\nconst root = getGlobal()\n\n\nroot.Omi = { h, version: '0.0.0' }\n\nfunction getGlobal() {\n  if (\n    typeof global !== 'object' ||\n    !global ||\n    global.Math !== Math ||\n    global.Array !== Array\n  ) {\n    if (typeof self !== 'undefined') {\n      return self\n    } else if (typeof window !== 'undefined') {\n      return window\n    } else if (typeof global !== 'undefined') {\n      return global\n    }\n    return (function () {\n      return this\n    })()\n  }\n  return global\n}\n\nexport {\n  render\n}\n","import { render } from '../../src/index'\n\nconst size = getSize();\n\n//全局 store或者局部 store，data全放这里，组件没有私有 data，只可以有 props\nconst store = {\n\n}\n\n//UI is UI，没有 data\nconst App = (props, store) => {\n  return <surface top={0} left={0} width={size.width} height={size.height} enableCSSLayout={true}>\n    <group style={getPageStyle()}>\n      <text style={getTitleStyle()}>\n        Professor PuddinPop\n   </text>\n      <group style={getImageGroupStyle()}>\n        <image src='https://placekitten.com/720/840' style={getImageStyle()} fadeIn={true} />\n      </group>\n      <text style={getExcerptStyle()}>\n        With these words the Witch fell down in a brown, melted, shapeless mass and began to spread over the clean boards of the kitchen floor.  Seeing that she had really melted away to nothing, Dorothy drew another bucket of water and threw it over the mess.  She then swept it all out the door.  After picking out the silver shoe, which was all that was left of the old woman, she cleaned and dried it with a cloth, and put it on her foot again.  Then, being at last free to do as she chose, she ran out to the courtyard to tell the Lion that the Wicked Witch of the West had come to an end, and that they were no longer prisoners in a strange land.\n   </text>\n    </group>\n  </surface>\n}\n\n//渲染并注入 store\nconsole.log(render(App, store))\n\nfunction getSize() {\n  return {\n    left: 0,\n    top: 0,\n    width: 420,\n    height: 740\n  }\n}\n\nfunction getPageStyle() {\n\n  return {\n    position: 'relative',\n    padding: 14,\n    width: size.width,\n    height: size.height,\n    backgroundColor: '#f7f7f7',\n    flexDirection: 'column'\n  };\n}\n\nfunction getImageGroupStyle() {\n  return {\n    position: 'relative',\n    flex: 1,\n    backgroundColor: '#eee'\n  };\n}\n\nfunction getImageStyle() {\n  return {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  };\n}\n\nfunction getTitleStyle() {\n  return {\n    fontFace: FontFace('Georgia'),\n    fontSize: 22,\n    lineHeight: 28,\n    height: 28,\n    marginBottom: 10,\n    color: '#333',\n    textAlign: 'center'\n  };\n}\n\nfunction getExcerptStyle() {\n  return {\n    fontFace: FontFace('Georgia'),\n    fontSize: 17,\n    lineHeight: 25,\n    marginTop: 15,\n    flex: 1,\n    color: '#333'\n  };\n}\n\nfunction FontFace() {\n\n}\n"],"names":["computeLayout","capitalizeFirst","str","charAt","toUpperCase","slice","getSpacing","node","type","suffix","location","key","style","getPositiveSpacing","isUndefined","value","undefined","getMargin","getPadding","getBorder","getPaddingAndBorder","getMarginAxis","axis","leading","trailing","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignItem","child","alignSelf","alignItems","getFlexDirection","flexDirection","getPositionType","position","getFlex","flex","isFlex","CSS_POSITION_RELATIVE","isFlexWrap","flexWrap","getDimWithMargin","layout","dim","isDimDefined","isPosDefined","pos","isMeasureDefined","getPosition","setDimensionFromStyle","fmaxf","getRelativePosition","row","column","a","b","CSS_UNDEFINED","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_COLUMN","CSS_JUSTIFY_FLEX_START","CSS_JUSTIFY_CENTER","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","CSS_ALIGN_FLEX_START","CSS_ALIGN_CENTER","CSS_ALIGN_STRETCH","CSS_POSITION_ABSOLUTE","layoutNode","parentMaxWidth","mainAxis","crossAxis","width","isRowUndefined","isColumnUndefined","measure_dim","measure","height","i","children","length","ii","definedMainDim","startLine","endLine","alreadyComputedNextLayout","linesCrossDim","linesMainDim","mainContentDim","flexibleChildrenCount","totalFlexible","nonFlexibleChildrenCount","nextContentDim","maxWidth","leadingMainDim","betweenMainDim","remainingMainDim","flexibleMainDim","crossDim","mainDim","containerMainAxis","containerCrossAxis","leadingCrossDim","alignItem","remainingCrossDim","root","rootNode","createNode","walkNode","layer","top","left","attributes","map","parentLeft","parentTop","frame","x","y","forEach","render","console","log","stack","h","lastSimple","simple","arguments","push","p","pop","String","getGlobal","Omi","version","global","Math","Array","self","window","size","getSize","store","App","props","getPageStyle","getTitleStyle","getImageGroupStyle","getImageStyle","getExcerptStyle","padding","backgroundColor","right","bottom","fontFace","FontFace","fontSize","lineHeight","marginBottom","color","textAlign","marginTop"],"mappings":"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"}